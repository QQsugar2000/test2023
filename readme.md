
# 测试情况说明

| 项目        | 内容   |
| --------   | -----:  |
| 姓名      | 夏多为   |
| 报考专业        |       计算机学院 电子信息(085400)   |
| 收到测试邮件时间        |    2023-02-25 08:15:25    |
| 测试进行时间        |    2023-02-25 16:00 - 2023-02-26 04:00    |
| 实际用时        |    约12个小时    |

尊敬的CAD实验室老师，您好！学生测试情况如上，因当天查阅邮件时间较迟，且寻求良好测试环境也使用了时间，所以导致开始时间较迟，已尽力在收到邮件一天内完成并返回结果。以下为测试相关说明。源代码已在文件中发送。
**本说明文档是用vscode进行编写的，可能在其他平台存在显示问题。**

# 算法描述
算法总体思想：根据数据给出的分段序号，对每段进行双调排序；对于每段，将其分为上半和下半段，分别进行递归排序为降序和升序（或者相反），对形成的双调序列进行合并；合并过程中，由于方便处理的双调序列元素个数总是2的幂次，则将整个数据分为2的幂次部分和其他部分分别处理。
#### 实现分段
```cpp
//对指定的输入格式进行分段的双调排序
void segmentedBitonicSort(float* data, int* seg_id, int* seg_start, int n, int m) {
    for (int i = 0; i < m; i++) {
        int start = seg_start[i];
        int end = seg_start[i+1];
        int size = end - start;
        bitonicSort(data+start,size,1);
    }
}
```
以上函数根据输入的seg_start信息分段进行处理，调用bitonicSort函数。
#### 递归进行排序
```cpp
// 对任意长度的序列进行递归双调排序
void bitonicSort(float *a, int len, bool up) { // up控制升序
    if (len > 1) {
        int m = len / 2;
        bitonicSort(a, m, !up); // 前半段降序排列
        bitonicSort(a + m, len - m, up); // 后半段升序排列
        bitonicMerge(a, len, up);//归并处理
    }
}
```
递归进行排序，通过输入参数控制前半段降序，后半段升序，获得能够进行归并的双调序列，并进行归并处理。
#### 对获取的序列合并
```cpp
void bitonicMerge(float *arr, int len, bool up) {
    if (len > 1) {
        int m = 1; //m是小于len的2的最大幂次
        while (m<len)
           m = m<<1;
        m = m>>1;
        for (int i = 0; i < len - m; ++i) {
            if (arr[i] > arr[i + m] == up){
                float temp = arr[i];
                arr[i] = arr[i+m];
                arr[i+m] = temp;
            }
        }
        bitonicMerge(arr, m, up); 
        bitonicMerge(arr + m, len - m, up);
    }
}
```
首先获取长度范围内2的最大幂次m，使用其将序列划分。这样，由于m一般大于len/2，会划分出一个短序列和长序列。然后依次对比arr[i]和arr[i + m]，并根据输入的布尔值up决定是否进行交换，由此会导致长序列的一部分和短序列进行交换，另一部分被置于一端，根据Batcher定理，会形成两个双调序列，再进行递归排序即可。
# 加分挑战
| 加分项目  | 结果 | 说明 |
| :------------: | :------------: | :------------: |
| 不递归 | 失败 | 尝试失败，代码多次出错而放弃，仅实现了对2的幂次的双调排序，在源码中保留了hBitonicSort函数有所体现 |
| 不调用函数  | 失败 | 尝试失败，由于不递归挑战失败，不调用函数挑战无法成功 |
| 内存高效 | 成功 | 关键函数未进行动态内存分配和使用STL |
| 可并行 | 成功 | 如果对本挑战要求理解正确，我的关键代码（交换部分）是在循环内实现的 |
| 不需内存 | 未尝试 | 由于前两条失败难以实现，但所有局部变量都是int、float或指针类 |
| 绝对鲁棒 | 未尝试 | 学生知识水平有限，难以实现 |
作为跨专业考生，学生已经尽力实现以上挑战，由于知识水平不足、代码积累有限，成果一般，望老师海涵。


# 测试用例说明
源代码中结合rand（）函数进行了随机生成测试样例，并对随机生成的样例构造、排序的结果进行输出。（可以修改生成的测试用例中的n、m值）
如下图，运行源码生成随机测试样例后，会输出未排序的数据、每段的起始位置，经过排序，再输出排序结果。可见图中排序结果正确。
![Alt text](/testoutput.png)
采用以下手动设计样例也可以得出正确输出。
```cpp
    const int n = 20;
    const int m = 5;
    float data[n] = {1.1, 3.3, 2.2, 4.4, 5.5, 1.2, 3.4, 2.3, 4.5, 1.3, 3.5, 2.4, 4.6, 1.4, 3.6, 2.5, 4.7, 1.5, 3.7, 2.6};
    int seg_id[n] = {0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4};
    int seg_start[m + 1] = {0, 5, 9, 13, 17, 20};
```
输出如下
```cpp
Sorted data:
1.1 2.2 3.3 4.4 5.5 1.2 2.3 3.4 4.5 1.3 2.4 3.5 4.6 1.4 2.5 3.6 4.7 1.5 2.6 3.7
```
# 性能分析
#### 时间复杂度
我实现的segmentedBitonicSort算法，其时间复杂度主要体现在交换过程中。对n个元素双调序列的一次交换，需要遍历到每个元素，时间复杂度为O(n),需要进行log2n次交换，所以对n个元素的双调排序，时间复杂度为O(nlogn)，由于总共输入了m个组的元素，假设每个组平均元素个数为n，则其时间复杂度为O(mnlogn)。
如图，采用CPU进行计算，在CodeBlocks执行环境下，包括生成一个包括100个元素的测试用例，和对其进行排序，共用时0.058s。
![Alt text](/time.png)
由于双调排序经常用于并行计算，发挥GPU计算的长处，所以如使用CUDA等平台，可以对代码的for循环等部分进行改造，可以获取更优性能。限于时间和水平，学生未能实现。
#### 空间复杂度
由于我实现的算法中进行了递归调用，每次对n个元素进行双调排序，都会进行递归，其空间复杂度为O(logn)。
# 参考文献
注：学生未进行代码的直接使用，主要对以下参考文献的代码进行了融合和改造。

1.geeksforgeeks教程网站的双调排序教程页面及其源码：https://www.geeksforgeeks.org/bitonic-sort/
2.纽约州立大学布法罗分校的双调排序课程文档：https://cse.buffalo.edu/faculty/miller/Courses/CSE633/Mullapudi-Spring-2014-CSE633.pdf
3.Stack overflow网站双调排序相关页面：https://stackoverflow.com/questions/49223372/bitonic-sort-calculating-complexity
4.搜索引擎（Google）和人工智能引擎（ChatGPT）
